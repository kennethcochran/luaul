-- OptimisticSIde
-- 5/1/2022
-- Luau parser

-- luacheck: push globals script
local AstNode = require(_VERSION == "Luau" and script.Parent.AstNode or "./AstNode.lua")
local Token = require(_VERSION == "Luau" and script.Parent.Token or "./Token.lua")
-- luacheck: pop

local Parser = {}
Parser.__index = Parser

function Parser.new(tokens)
	local self = {}
	setmetatable(self, Parser)

	self._tokens = tokens
	self._token = self._tokens[1]
	self._position = 1

	return self
end

function Parser.is(object)
	return type(object) == "table" and getmetatable(object) == Parser
end

--[[
	Determines whether a statement is the last statement of a block.

	This saves us time because we won't have to parse statements after
	it.
]]
function Parser.isLastStat(stat)
	return stat.kind == AstNode.Kind.Break
		or stat.Kind == AstNode.Kind.Continue
		or stat.kind == AstNode.Kind.Break
		or stat.kind == AstNode.Kind.Return
end

--[[
	Throws an error generated by the parser.

	Note that this can be overriden by the user (since it's retrieved
	through the __index metamethod).
]]
-- luacheck: ignore self
function Parser:_error(formatString, ...)
	error(formatString:format(...))
end

--[[
	Accepts a token if valid, and returns nil otherwise.
]]
function Parser:_accept(tokenKind)
	local token = self._token
	if token and token.kind == tokenKind then
		self:_advance()
		return token
	end
end

--[[
	Expects to read a certain type of token. If this token is not found,
	then it will throw a parse-error.
]]
function Parser:_expect(tokenKind)
	local token = self:_accept(tokenKind)
	if not token or token.kind ~= tokenKind then
		self:_error(
			"Expected %s, got %s at %s",
			Token.kindString(tokenKind),
			Token.kindString(token.kind),
			token.position
		)
		return
	end
	return token
end

function Parser:parseSimpleExpr()
	-- Parser for simple tokens, where the corresponding node
	-- can be found through a table.
	local simpleTokens = {
		[Token.Kind.True] = AstNode.Kind.True,
		[Token.Kind.False] = AstNode.Kind.False,
		[Token.Kind.Nil] = AstNode.Kind.Nil,
		[Token.Kind.Dot3] = AstNode.Kind.Dot3,
	}
	local nodeKind = simpleTokens[self._token.kind]
	if nodeKind then
		return AstNode.new(nodeKind)
	end

	-- Table constructor parser.
	if self:_accept(Token.Kind.LeftBrace) then
		local fields = {}

		while not self:_accept(Token.Kind.RightBrace) do
			-- [exp] = exp
			if self:_accept(Token.Kind.LeftBracket) then
				local key = self:parseExpr()
				self:_expect(Token.Kind.RightBracket)

				self:_expect(Token.Kind.Equals)
				local value = self:parseExpr()
				table.insert(fields, { key, value })

			elseif self:_peekAccept(Token.Kind.Name) then
				-- If we see a name, it could either be the key of a value
				-- in the table, or just be a variable.
				local name = self:_accept(Token.Kind.Name)

				-- name = exp
				if self:_accept(Token.Kind.Equals) then
					local value = self:parseExpr()
					table.insert(fields, { name, value })

				-- name
				else
					table.insert(fields, name)
				end
			end

			-- TODO: Accept a semi-colon or comma here. Also, how will we
			-- ensure the user placed a semi-colon or comma before the next
			-- field?
		end

		return AstNode.fromArray(AstNode.Kind.TableConstructor, fields)
	end
end

function Parser:parsePrefixExpr()
	if self:_accept(Token.Kind.LeftParen) then
		local expr = self:parseExpr()
		self:_expect(Token.Kind.RightParen)
		return expr
	end

	-- TODO: Parse name expression.
end

function Parser:parsePrimaryExpr()
	local expr = self:parsePrefixExpr()

	while true do
		-- prefixexpr.name
		if self:_accept(Token.Kind.Dot) then
			expr = AstNode.new(AstNode.Kind.IndexName, expr, self:parseName())

		-- prefixexpr[expr]
		elseif self:_accept(Token.Kind.LeftBracket) then
			expr = AstNode.new(AstNode.Kind.IndexExpr, expr, self:parseExpr())
			self:_expect(Token.Kind.RightBracket)

		-- prefixexpr:name(functionargs)
		elseif self:_accept(Token.Kind.Colon) then
			local func = AstNode.new(AstNode.Kind.ColonIndex, expr, self:parseName())
			-- TODO: Provide `self` flag to Parser::parseFunctionArgs?
			self:_expect(Token.Kind.LeftParen)
			expr = AstNode.new(AstNode.Kind.FunctionCall, func, self:parseFunctionArgs())
			self:_expect(Token.Kind.RightParen)

		-- prefixexpr(functionargs)
		elseif self:_accept(Token.Kind.LeftParen) then
			expr = AstNode.new(AstNode.Kind.FunctionCall, expr, self:parseFunctionArgs())
			self:_expect(Token.Kind.RightParen)

		else
			break
		end
	end

	return expr
end

function Parser:parseStat()
	-- Do-block parser.
	if self:_accept(Token.Kind.Do) then
		local body = self:parseBlock()
		self:_expect(Token.Kind.End)
		return AstNode.new(AstNode.Kind.DoBlock, body)
	end

	-- While-loop parser.
	if self:_accept(Token.Kind.While) then
		local condition = self:parseExpr()
		self:_expect(Token.Kind.Do)

		local body = self:parseBlock()
		self:_expect(Token.Kind.End)

		return AstNode.new(AstNode.Kind.WhileLoop, condition, body)
	end

	-- Repeat-until loop parser.
	-- Essentially the same as the while-loop parser, except it expects
	-- a `until` instead of `do`.
	if self:_accept(Token.Kind.Repeat) then
		local condition = self:parseExpr()
		self:_expect(Token.Kind.Until)

		local body = self:parseBlock()
		self:_expect(Token.Kind.End)

		return AstNode.new(AstNode.Kind.RepeatLoop, condition, body)
	end

	-- If-block parser.
	if self:_accept(Token.Kind.If) then
		local ifCondition = self:parseExpr()
		self:_expect(Token.Kind.Then)

		local thenBlock = self:parseBlock()
		local blocks = { { ifCondition, thenBlock }  }

		while self:_accept(Token.Kind.ElseIf) do
			local elseIfCondition = self:parseExpr()
			self:_expect(Token.Kind.Then)
			table.insert(blocks, { elseIfCondition, self:parseBlock() })
		end

		if self:_accept(Token.Kind.Else) then
			table.insert(blocks, self:parseBlock())
		end

		self:_accept(Token.Kind.End)
		-- Each block is in the block array (in order)
		-- `elseif` and `if` statements are stored as an array containing
		-- their condition and block. `then` statements are just stored
		-- as just their block.
		return AstNode.fromArray(AstNode.Kind.IfStat, blocks)
	end
end

function Parser:parseBlock()
	local stats = {}
	local stat

	repeat
		stat = self:parseStat()
		table.insert(stats, stat)
		self:_accept(Token.Kind.SEMI)
	until not self:isLastStat(stat)

	return AstNode.fromArray(AstNode.Kind.Block, stats)
end

--[[
	Main parsing routine. Parses a chunk of luau code.
--]]
function Parser:parseChunk()
	local root = self:parseBlock()
	self.result = root
	return root
end

return Parser
